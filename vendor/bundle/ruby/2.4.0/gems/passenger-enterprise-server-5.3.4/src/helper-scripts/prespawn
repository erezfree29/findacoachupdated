#!/usr/bin/env ruby
#  Phusion Passenger - https://www.phusionpassenger.com/
#  Copyright (c) 2010-2017 Phusion Holding B.V.
#
#  "Passenger", "Phusion Passenger" and "Union Station" are registered
#  trademarks of Phusion Holding B.V.
#
#  See LICENSE file for license information.

# Script usage: prespawn <url> <timeout>
# - where <url> may be a unix:// or http(s):// type url to use for a HEAD request
# - where <timeout> is an optional timeout in seconds for the request (default: 10 sec)
# - nonzero return value means error: 1 = invalid url, 2 = request timed out
#
# N.B. the host part of the url is used in the "Host:" header, but the request is always sent
# to the local host to avoid landing on a load balancer (that might not come back to this host).
# Also, query parts (?param=val) are dropped.

STDOUT.sync = true
STDERR.sync = true

require 'uri'
require 'socket'
require 'timeout'
require 'base64'

class PrespawnLocation
  class InvalidURLError < RuntimeError
    def initialize(url)
      @url = url
    end

    def to_s
      message
    end

    def message
      "'#{@url}' is not a valid URL."
    end
  end

  def self.parse(url)
    uri = uri_for(url)

    if uri.scheme == 'unix' || uri.host == 'unix'
      location = UNIXPrespawnLocation.new(uri)
    else
      case uri.scheme
      when 'http'
        location = TCPPrespawnLocation.new(uri)
      when 'https'
        location = SSLPrespawnLocation.new(uri)
      end
    end

    unless location
      raise InvalidURLError, url
    end

    location
  end

  def self.uri_for(url)
    URI.parse(url)
  rescue URI::InvalidURIError
    raise InvalidURLError, url
  end

  def initialize(uri)
    @uri = uri
  end

  def request_path
    @uri.path.empty? ? '/' : @uri.path
  end

  def request_host
    @uri.host
  end

  def socket
    @socket ||= connect
  end

  if Base64.respond_to?(:strict_encode64)
    def base64(data)
      Base64.strict_encode64(data)
    end
  else
    # Base64-encodes the given data. Newlines are removed.
    # This is like `Base64.strict_encode64`, but also works
    # on Ruby 1.8 which doesn't have that method.
    def base64(data)
      result = Base64.encode64(data)
      result.delete!("\n")
      result
    end
  end

  def head_request(timeout)
    socket.write("HEAD #{request_path} HTTP/1.1\r\n")
    socket.write("Host: #{request_host}\r\n")
    socket.write("Authorization: Basic " + base64(@uri.userinfo) + "\r\n") if @uri.userinfo
    socket.write("Connection: close\r\n")
    socket.write("\r\n")

    Timeout.timeout(timeout) do
      socket.read
    end
  end
end

class TCPPrespawnLocation < PrespawnLocation
  def request_port
    @uri.port
  end

  def connect
    TCPSocket.new('127.0.0.1', request_port)
  rescue Errno::ECONNREFUSED
    TCPSocket.new('::1', request_port)
  end
end

class SSLPrespawnLocation < TCPPrespawnLocation
  def connect
    require 'openssl'
    socket = OpenSSL::SSL::SSLSocket.new(super)
    socket.sync_close = true
    socket.connect
    socket
  end
end

class UNIXPrespawnLocation < PrespawnLocation
  def request_path
    @uri.path.split(':', 2).last
  end

  def request_host
    '_'
  end

  def socket_path
    @uri.path.split(':', 2).first
  end

  def connect
    UNIXSocket.new(socket_path)
  end
end

url = ARGV.shift
timeout = ARGV.shift
warn = ![nil,""].include?(timeout)
if warn
  timeout = timeout.to_i
else
  timeout = 10
end
begin
  prespawn_location = PrespawnLocation.parse(url)
rescue PrespawnLocation::InvalidURLError => e
  STDERR.puts "*** ERROR: #{e}"
  exit 1
end

begin
  prespawn_location.head_request(timeout)
rescue Timeout::Error
  STDERR.puts "*** WARNING: prestart request to #{url} timed out after #{timeout} sec." if warn
  exit 2
end
