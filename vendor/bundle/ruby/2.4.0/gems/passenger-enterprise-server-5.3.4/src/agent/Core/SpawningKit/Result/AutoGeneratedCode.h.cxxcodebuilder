#  Phusion Passenger - https://www.phusionpassenger.com/
#  Copyright (c) 2017 Phusion Holding B.V.
#
#  "Passenger", "Phusion Passenger" and "Union Station" are registered
#  trademarks of Phusion Holding B.V.
#
#  See LICENSE file for license information.

require 'build/support/vendor/cxx_hinted_parser/lib/cxx_hinted_parser'

def main
  result_class_fields = parse_result_class_fields
  comment copyright_header_for(__FILE__), 1
  separator

  comment %q{
    SpawningKit/Result/AutoGeneratedCode.h is automatically generated from
    SpawningKit/Result/AutoGeneratedCode.h.cxxcodebuilder by the build system.
    It uses the comment hints from SpawningKit/Result.h.

    To force regenerating this file:
      rm -f src/agent/Core/SpawningKit/Result/AutoGeneratedCode.h
      rake src/agent/Core/SpawningKit/Result/AutoGeneratedCode.h
  }

  separator


  function 'inline void Passenger::SpawningKit::Result::validate_autoGeneratedCode(' \
    'vector<StaticString> &internalFieldErrors, ' \
    'vector<StaticString> &appSuppliedFieldErrors) const' \
  do
    add_code %q{
      const Result &result = *this;
    }

    separator
    excluded_field_names = []

    result_class_fields.each do |field|
      if field.metadata[:supplied_by_app]
        error_collection = 'appSuppliedFieldErrors'
      else
        error_collection = 'internalFieldErrors'
      end
      if field.metadata[:require_non_empty]
        add_code %Q{
          if (OXT_UNLIKELY(#{field.name}.empty())) {
            #{error_collection}.push_back(P_STATIC_STRING("#{filename_for(field)} may not be empty"));
          }
        }
      elsif field.metadata[:require]
        add_code %Q{
          if (OXT_UNLIKELY(!(#{field.metadata[:require]}))) {
            #{error_collection}.push_back(P_STATIC_STRING("#{filename_for(field)} is not valid"));
          }
        }
      else
        excluded_field_names << field.name
      end
    end

    separator
    comment "Excluded:\n\n#{excluded_field_names.join("\n")}"
  end
end

def filename_for(field)
  key = field.metadata[:supplied_by_app]
  if key.is_a?(String)
    key
  else
    field.name.gsub(/([A-Z])/, '_\1').downcase
  end
end

def read_expression_for(field)
  case field.type
  when 'string'
    %Q{strip(readAll(dir + "/#{filename_for(field)}"))}
  when 'vector<Socket>'
    %Q{parseSocketJsonFile(dir + "/#{filename_for(field)}")}
  else
    raise "Unsupported field type '#{field.type}' for field #{field.name}"
  end
end

def parse_result_class_fields
  result_h = File.dirname(__FILE__) + '/../Result.h'
  parser = CxxHintedParser::Parser.load_file(result_h).parse
  parser.structs['Result']
end

main
